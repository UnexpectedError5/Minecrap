<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Voxel World</title>
<style>

#hotbar {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 6px;
  padding: 8px;
  background: rgba(0, 0, 0, 0.35);
  border-radius: 8px;
}

#hotbar .slot {
  width: 48px;
  height: 48px;
  background: rgba(255, 255, 255, 0.15);
  border: 2px solid rgba(255, 255, 255, 0.25);
  border-radius: 4px;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: monospace;
  color: white;
  font-size: 12px;
}

#hotbar .slot.selected {
  border-color: yellow;
  background: rgba(255, 255, 0, 0.2);
}

#hotbar .slot .count {
  position: absolute;
  bottom: 2px;
  right: 4px;
  font-size: 12px;
  color: white;
}

#hotbar .slot .icon {
  font-size: 10px;
  text-align: center;
  pointer-events: none;
}

  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    height: 100%;
    background: #000;
    font-family: sans-serif;
  }

  #hud {
    position: fixed;
    left: 50%;
    bottom: 20px;
    transform: translateX(-50%);
    display: flex;
    gap: 6px;
    padding: 6px 8px;
    background: rgba(0,0,0,0.4);
    border-radius: 6px;
    z-index: 10;
  }

  .slot {
    width: 32px;
    height: 32px;
    border: 2px solid rgba(255,255,255,0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    color: #fff;
    font-size: 14px;
    box-sizing: border-box;
  }

  .slot.selected {
    border-color: #ffd700;
    background: rgba(255,255,255,0.15);
  }

  #crosshair {
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 32px;
    font-weight: bold;
    pointer-events: none;
    user-select: none;
    text-shadow: 0 0 4px black;
    z-index: 5;
  }

  #info {
    position: fixed;
    left: 10px;
    top: 10px;
    color: #fff;
    font-size: 12px;
    text-shadow: 0 0 4px black;
    z-index: 10;
  }
</style>
</head>
<body>

<div id="hotbar">
  <div class="slot" data-slot="0"><span class="icon"></span><span class="count"></span></div>
  <div class="slot" data-slot="1"><span class="icon"></span><span class="count"></span></div>
  <div class="slot" data-slot="2"><span class="icon"></span><span class="count"></span></div>
  <div class="slot" data-slot="3"><span class="icon"></span><span class="count"></span></div>
  <div class="slot" data-slot="4"><span class="icon"></span><span class="count"></span></div>
  <div class="slot" data-slot="5"><span class="icon"></span><span class="count"></span></div>
  <div class="slot" data-slot="6"><span class="icon"></span><span class="count"></span></div>
  <div class="slot" data-slot="7"><span class="icon"></span><span class="count"></span></div>
  <div class="slot" data-slot="8"><span class="icon"></span><span class="count"></span></div>
</div>


<div id="crosshair">+</div>
<div id="info"></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
function removeBlockAt(x, y, z) {
  const info = getChunkAndLocal(x, y, z);
  if (!info) return;

  const { chunk, lx, lz } = info;
  const k = blockKey(lx, y, lz);

  const block = chunk.blocks.get(k);
  if (!block) return;

  const type = block.type;

  // Remove the block
  chunk.blocks.delete(k);
  buildChunkMeshes(chunk);

function removeBlockAt(x, y, z) {
  const info = getChunkAndLocal(x, y, z);
  if (!info) return;

  const { chunk, lx, lz } = info;
  const k = blockKey(lx, y, lz);

  const block = chunk.blocks.get(k);
  if (!block) return;

  const type = block.type;

  // Remove the block
  chunk.blocks.delete(k);
  buildChunkMeshes(chunk);

  // Add to inventory (new system)
  addToInventory(type);

  // Update UI
  updateHotbarUI();
}

}
const infoEl = document.getElementById("info");


// -----------------------------------------------------
// CORE SETUP
// -----------------------------------------------------

// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb); // sky blue

// Camera
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting (fast + good looking)
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
scene.add(hemi);

// Resize handling
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
// -----------------------------------------------------
// INPUT + CAMERA LOOK
// -----------------------------------------------------

const keys = {};

window.addEventListener("keydown", e => {
  keys[e.code] = true;
});

window.addEventListener("keyup", e => {
  keys[e.code] = false;
});

// Pointer lock
const canvas = renderer.domElement;

canvas.addEventListener("click", () => {
  canvas.requestPointerLock();
});

let yaw = 0;
let pitch = 0;
camera.rotation.order = "YXZ";

document.addEventListener("mousemove", e => {
  if (document.pointerLockElement === canvas) {
    yaw   -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;

    const limit = Math.PI / 2 - 0.01;
    pitch = Math.max(-limit, Math.min(limit, pitch));
  }
});

// -----------------------------------------------------
// PLAYER STATE
// -----------------------------------------------------

const player = {
  pos: new THREE.Vector3(0, 30, 0),   // start above terrain
  vel: new THREE.Vector3(0, 0, 0),

  width: 0.6,
  depth: 0.6,
  height: 1.7,

  onGround: false
};

const GRAVITY = -20;
const WALK_SPEED = 4.3;
const SPRINT_SPEED = 7.5;
const JUMP_SPEED = 8;

// -----------------------------------------------------
// HOTBAR + INVENTORY
// -----------------------------------------------------

const MAX_STACK = 64;

const inventory = [
  { type: null, count: 0 },
  { type: null, count: 0 },
  { type: null, count: 0 },
  { type: null, count: 0 },
  { type: null, count: 0 },
  { type: null, count: 0 },
  { type: null, count: 0 },
  { type: null, count: 0 },
  { type: null, count: 0 }
];

let selectedSlot = 0;

// Update UI
function updateHotbarUI() {
  const slots = document.querySelectorAll("#hotbar .slot");

  slots.forEach((slot, i) => {
    const icon = slot.querySelector(".icon");
    const count = slot.querySelector(".count");
    const item = inventory[i];   // ✅ FIXED

    slot.classList.toggle("selected", i === selectedSlot);

    if (!item.type || item.count === 0) {
      icon.textContent = "";
      count.textContent = "";
    } else {
      icon.textContent = item.type;
      count.textContent = item.count;
    }
  });
}

updateHotbarUI();

// Number keys switch slots
window.addEventListener("keydown", e => {
  if (e.code.startsWith("Digit")) {
    const n = Number(e.code.slice(5)) - 1;
    if (n >= 0 && n < 9) {
      selectedSlot = n;
      updateHotbarUI();
    }
  }
});

// Add item
function addToInventory(type) {
  for (let i = 0; i < 9; i++) {
    const slot = inventory[i];   // ✅ FIXED
    if (slot.type === type && slot.count < MAX_STACK) {
      slot.count++;
      updateHotbarUI();
      return true;
    }
  }

  for (let i = 0; i < 9; i++) {
    const slot = inventory[i];   // ✅ FIXED
    if (slot.type === null) {
      slot.type = type;
      slot.count = 1;
      updateHotbarUI();
      return true;
    }
  }

  return false;
}

// Remove item
function removeFromInventory(type) {
  const slot = inventory[selectedSlot];   // ✅ FIXED

  if (slot.type !== type || slot.count === 0) return false;

  slot.count--;

  if (slot.count === 0) slot.type = null;

  updateHotbarUI();
  return true;
}

// Break block
function removeBlockAt(x, y, z) {
  const info = getChunkAndLocal(x, y, z);
  if (!info) return;

  const { chunk, lx, lz } = info;
  const k = blockKey(lx, y, lz);

  const block = chunk.blocks.get(k);
  if (!block) return;

  const type = block.type;

  // Remove the block
  chunk.blocks.delete(k);
  buildChunkMeshes(chunk);

  // Add to inventory (new system)
  addToInventory(type);

  // Update UI
  updateHotbarUI();
}
// -----------------------------------------------------
// WORLD CONSTANTS + MATERIALS
// -----------------------------------------------------

const CHUNK_SIZE = 16;
const RENDER_RADIUS = 3;      // nearby chunks only (fast)
const UNLOAD_RADIUS = 5;      // unload far chunks
const SEA_LEVEL = 8;
const BASE_HEIGHT = 12;
const HEIGHT_SCALE = 18;

const chunks = new Map();     // "cx,cz" -> chunk object
const blockKey = (x, y, z) => `${x},${y},${z}`;

const blockGeo = new THREE.BoxGeometry(1, 1, 1);

// Materials (simple + fast)
const mats = {
  grass: new THREE.MeshStandardMaterial({ color: 0x3b7a1a }),
  dirt:  new THREE.MeshStandardMaterial({ color: 0x8b4513 }),
  stone: new THREE.MeshStandardMaterial({ color: 0x888888 }),
  sand:  new THREE.MeshStandardMaterial({ color: 0xdcc18b }),
  wood:  new THREE.MeshStandardMaterial({ color: 0x8b5a2b }),
  leaf:  new THREE.MeshStandardMaterial({ color: 0x2fa32f }),
  water: new THREE.MeshStandardMaterial({ color: 0x4060ff, transparent: true, opacity: 0.7 })
};

// -----------------------------------------------------
// RANDOM TERRAIN (noise-like, fast, no libraries)
// -----------------------------------------------------

function hash2(x, z) {
  const s = Math.sin(x * 127.1 + z * 311.7) * 43758.5453123;
  return s - Math.floor(s);
}

function smoothNoise(x, z) {
  return hash2(Math.floor(x / 4), Math.floor(z / 4));
}

function terrainHeight(x, z) {
  // Large-scale shape (biome height)
  const large = smoothNoise(x / 32, z / 32) * 20; // big hills

  // Medium-scale rolling terrain
  const medium = smoothNoise(x / 8, z / 8) * 8;

  // Small-scale detail
  const small = smoothNoise(x, z) * 2;

  // Combine layers
  let h = BASE_HEIGHT + large + medium + small;

  // Lakes: flatten low areas
  if (h < SEA_LEVEL + 2) {
    h = SEA_LEVEL - 1;
  }

  return Math.floor(h);
}

// -----------------------------------------------------
// CHUNK GENERATION (random terrain + trees)
// -----------------------------------------------------

function ensureChunk(cx, cz) {
  const ck = `${cx},${cz}`;
  if (chunks.has(ck)) return;

  const chunk = {
    cx, cz,
    blocks: new Map(),
    meshes: []
  };

  // Generate terrain blocks
  for (let x = 0; x < CHUNK_SIZE; x++) {
    for (let z = 0; z < CHUNK_SIZE; z++) {
      const wx = cx * CHUNK_SIZE + x;
      const wz = cz * CHUNK_SIZE + z;

      const h = terrainHeight(wx, wz);

      for (let y = 0; y <= h; y++) {
        let type;

        if (y === h) {
          type = (h <= SEA_LEVEL + 1) ? "sand" : "grass";
        } else if (y >= h - 3) {
          type = "dirt";
        } else {
          type = "stone";
        }

        chunk.blocks.set(blockKey(x, y, z), { type });
      }

      // Water fill
      for (let y = h + 1; y <= SEA_LEVEL; y++) {
        const k = blockKey(x, y, z);
        if (!chunk.blocks.has(k)) {
          chunk.blocks.set(k, { type: "water" });
        }
      }

      // Trees
      if (h > SEA_LEVEL + 1) {
        const r = hash2(wx, wz);
        if (r > 0.985) {
          trySpawnTree(wx, h + 1, wz, chunk, x, z, cx, cz);
        }
      }
    }
  }

  // Build chunk mesh (Part 5)
  chunks.set(ck, chunk);
}

// -----------------------------------------------------
// TREE GENERATION
// -----------------------------------------------------
function trySpawnTree(wx, wy, wz, chunk, lx, lz, cx, cz) {
  const trunkHeight = 4 + Math.floor(hash2(wx * 3, wz * 5) * 3);

  // Trunk
  for (let i = 0; i < trunkHeight; i++) {
    const y = wy + i;
    const k = blockKey(lx, y, lz);
    if (!chunk.blocks.has(k)) {
      chunk.blocks.set(k, { type: "wood" });
    }
  }

  // Leaves
  const top = wy + trunkHeight;

  for (let ox = -2; ox <= 2; ox++) {
    for (let oy = -2; oy <= 2; oy++) {
      for (let oz = -2; oz <= 2; oz++) {

        if (ox*ox + oy*oy + oz*oz > 5) continue;

        const bx = wx + ox;
        const by = top + oy;
        const bz = wz + oz;

        const localX = bx - cx * CHUNK_SIZE;
        const localZ = bz - cz * CHUNK_SIZE;

        if (
          localX < 0 || localX >= CHUNK_SIZE ||
          localZ < 0 || localZ >= CHUNK_SIZE
        ) continue;

        const k = blockKey(localX, by, localZ);
        if (!chunk.blocks.has(k)) {
          chunk.blocks.set(k, { type: "leaf" });
        }
      }
    }
  }
}

// -----------------------------------------------------
// CHUNK MESHING (MERGED GEOMETRY — HUGE FPS BOOST)
// -----------------------------------------------------

function clearChunkMeshes(chunk) {
  for (const m of chunk.meshes) {
    scene.remove(m);
    m.geometry.dispose();
  }
  chunk.meshes.length = 0;
}

function buildChunkMeshes(chunk) {
  clearChunkMeshes(chunk);

  // Group block positions by type
  const typeToPositions = {};

  for (const [k, b] of chunk.blocks.entries()) {
    if (b.type === "water") continue; // skip water for performance
    if (!typeToPositions[b.type]) typeToPositions[b.type] = [];

    const [lx, ly, lz] = k.split(",").map(Number);
    typeToPositions[b.type].push({ lx, ly, lz });
  }

  // Build one merged mesh per block type
  for (const type in typeToPositions) {
    const positions = typeToPositions[type];
    if (positions.length === 0) continue;

    const geo = new THREE.BufferGeometry();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];

    let indexOffset = 0;

    const baseGeo = blockGeo;
    const basePos = baseGeo.attributes.position;
    const baseNorm = baseGeo.attributes.normal;
    const baseUV  = baseGeo.attributes.uv;
    const baseIndex = baseGeo.index;

    for (const p of positions) {
      const wx = chunk.cx * CHUNK_SIZE + p.lx;
      const wy = p.ly;
      const wz = chunk.cz * CHUNK_SIZE + p.lz;

      // Copy vertices
      for (let i = 0; i < basePos.count; i++) {
        vertices.push(
          basePos.getX(i) + wx + 0.5,
          basePos.getY(i) + wy + 0.5,
          basePos.getZ(i) + wz + 0.5
        );
        normals.push(
          baseNorm.getX(i),
          baseNorm.getY(i),
          baseNorm.getZ(i)
        );
        uvs.push(
          baseUV.getX(i),
          baseUV.getY(i)
        );
      }

      // Copy indices
      for (let i = 0; i < baseIndex.count; i++) {
        indices.push(baseIndex.getX(i) + indexOffset);
      }

      indexOffset += basePos.count;
    }

    geo.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
    geo.setAttribute("normal",   new THREE.Float32BufferAttribute(normals, 3));
    geo.setAttribute("uv",       new THREE.Float32BufferAttribute(uvs, 2));
    geo.setIndex(indices);
    geo.computeBoundingSphere();

    const mesh = new THREE.Mesh(geo, mats[type]);
    scene.add(mesh);
    chunk.meshes.push(mesh);
  }
}
// -----------------------------------------------------
// VOXEL RAYMARCHING (TRUE MINECRAFT-STYLE BLOCK PICKING)
// -----------------------------------------------------

const RAY_STEP = 0.25;      // larger step = faster, still accurate
const RAY_MAX_DIST = 5;     // 5-block reach

function raycastBlock() {
  const dir = new THREE.Vector3(0, 0, -1)
    .applyEuler(camera.rotation)
    .normalize();

  const pos = camera.position.clone();
  let dist = 0;

  while (dist < RAY_MAX_DIST) {
    pos.addScaledVector(dir, RAY_STEP);
    dist += RAY_STEP;

    const bx = Math.floor(pos.x);
    const by = Math.floor(pos.y);
    const bz = Math.floor(pos.z);

    const info = getChunkAndLocal(bx, by, bz);
    if (!info) continue;

    const { chunk, lx, lz } = info;
    const k = blockKey(lx, by, lz);

    if (chunk.blocks.has(k)) {
      // Compute face normal
      const hitPos = pos.clone();
      const local = hitPos.clone().sub(new THREE.Vector3(bx + 0.5, by + 0.5, bz + 0.5));

      const abs = new THREE.Vector3(Math.abs(local.x), Math.abs(local.y), Math.abs(local.z));
      let normal = new THREE.Vector3();

      if (abs.x > abs.y && abs.x > abs.z) {
        normal.set(Math.sign(local.x), 0, 0);
      } else if (abs.y > abs.x && abs.y > abs.z) {
        normal.set(0, Math.sign(local.y), 0);
      } else {
        normal.set(0, 0, Math.sign(local.z));
      }

      return {
        blockPos: new THREE.Vector3(bx, by, bz),
        hitPos,
        normal
      };
    }
  }

  return null;
}

// -----------------------------------------------------
// COLLISION HELPERS
// -----------------------------------------------------

function nearbyBlocks(px, py, pz) {
  const out = [];

  // Only check a small area around the player (fast)
  for (let x = Math.floor(px - 1); x <= Math.floor(px + 1); x++) {
    for (let y = Math.floor(py - 2); y <= Math.floor(py + 2); y++) {
      for (let z = Math.floor(pz - 1); z <= Math.floor(pz + 1); z++) {
        const info = getChunkAndLocal(x, y, z);
        if (!info) continue;

        const { chunk, lx, lz } = info;
        const k = blockKey(lx, y, lz);

        if (chunk.blocks.has(k)) {
          out.push({ x, y, z });
        }
      }
    }
  }

  return out;
}

function aabb(ax, ay, az, aw, ah, ad, bx, by, bz, bw, bh, bd) {
  return (
    ax < bx + bw &&
    ax + aw > bx &&
    ay < by + bh &&
    ay + ah > by &&
    az < bz + bd &&
    az + ad > bz
  );
}

function moveAxis(axis, amount) {
  player.pos[axis] += amount;

  const w = player.width;
  const d = player.depth;
  const h = player.height;

  const minX = player.pos.x - w / 2;
  const minY = player.pos.y;
  const minZ = player.pos.z - d / 2;

  for (const b of nearbyBlocks(player.pos.x, player.pos.y, player.pos.z)) {
    if (aabb(minX, minY, minZ, w, h, d, b.x, b.y, b.z, 1, 1, 1)) {
      player.pos[axis] -= amount;
      return false;
    }
  }

  return true;
}

// -----------------------------------------------------
// MOVEMENT (WALKING, SPRINTING, JUMPING, GRAVITY)
// -----------------------------------------------------

function updateMovement(dt) {
  let forward = 0;
  let right = 0;

  if (keys["KeyW"]) forward += 1;
  if (keys["KeyS"]) forward -= 1;
  if (keys["KeyD"]) right += 1;
  if (keys["KeyA"]) right -= 1;

  const baseSpeed = keys["ShiftLeft"] ? SPRINT_SPEED : WALK_SPEED;

  const speed = baseSpeed * dt;

  // Movement directions based on camera yaw
  const dirForward = new THREE.Vector3(
    -Math.sin(yaw),
    0,
    -Math.cos(yaw)
  );

  const dirRight = new THREE.Vector3(
    Math.cos(yaw),
    0,
    -Math.sin(yaw)
  );

  const move = new THREE.Vector3();
  move.addScaledVector(dirForward, forward);
  move.addScaledVector(dirRight, right);

  if (move.lengthSq() > 0) {
    move.normalize().multiplyScalar(speed);

    moveAxis("x", move.x);
    moveAxis("z", move.z);
  }

  // Jump
  if (player.onGround && keys["Space"]) {
    player.vel.y = JUMP_SPEED;
    player.onGround = false;
  }

  // Gravity
  player.vel.y += GRAVITY * dt;

  // Vertical movement with collision
  if (!moveAxis("y", player.vel.y * dt)) {
    if (player.vel.y < 0) player.onGround = true;
    player.vel.y = 0;
  }
}
// -----------------------------------------------------
// BLOCK BREAKING & PLACING
// -----------------------------------------------------

// Prevent right‑click menu
window.addEventListener("contextmenu", e => e.preventDefault());

window.addEventListener("mousedown", e => {
  if (document.pointerLockElement !== canvas) return;

  const hit = raycastBlock();
  if (!hit) return;

  const { blockPos } = hit;

  // ---------------------------------------------
  // LEFT CLICK = BREAK BLOCK
  // ---------------------------------------------
  if (e.button === 0) {
    removeBlockAt(blockPos.x, blockPos.y, blockPos.z);
  }

  // ---------------------------------------------
  // RIGHT CLICK = PLACE BLOCK
  // ---------------------------------------------
  if (e.button === 2) {
  const type = inventory[selectedSlot].type;
  if (!type) return;

  const px = hit.blockPos.x + hit.normal.x;
  const py = hit.blockPos.y + hit.normal.y;
  const pz = hit.blockPos.z + hit.normal.z;

  // Prevent placing inside the player
  if (
    px > player.pos.x - 0.5 && px < player.pos.x + 0.5 &&
    py > player.pos.y - 0.1 && py < player.pos.y + player.height &&
    pz > player.pos.z - 0.5 && pz < player.pos.z + 0.5
  ) {
    return;
  }

  if (removeFromInventory(type)) {
    addBlockAt(px, py, pz, type);
  }
}
}); // <--- THIS was missing
// -----------------------------------------------------
// CHUNK LOOKUP + ADD/REMOVE BLOCK HELPERS
// -----------------------------------------------------

function getChunkAndLocal(x, y, z) {
  const cx = Math.floor(x / CHUNK_SIZE);
  const cz = Math.floor(z / CHUNK_SIZE);

  const lx = x - cx * CHUNK_SIZE;
  const lz = z - cz * CHUNK_SIZE;

  const ck = `${cx},${cz}`;
  const chunk = chunks.get(ck);

  if (!chunk) return null;

  return { chunk, cx, cz, lx, y, lz, ck };
}

function updateChunksAroundPlayer() {
  const pcx = Math.floor(player.pos.x / CHUNK_SIZE);
  const pcz = Math.floor(player.pos.z / CHUNK_SIZE);

  // Load nearby chunks
  for (let x = pcx - RENDER_RADIUS; x <= pcx + RENDER_RADIUS; x++) {
    for (let z = pcz - RENDER_RADIUS; z <= pcz + RENDER_RADIUS; z++) {
      ensureChunk(x, z);
      const ck = `${x},${z}`;
      const chunk = chunks.get(ck);
      if (chunk && chunk.meshes.length === 0) {
        buildChunkMeshes(chunk);
      }
    }
  }

  // Unload far chunks
  for (const [ck, chunk] of chunks.entries()) {
    const dx = chunk.cx - pcx;
    const dz = chunk.cz - pcz;

    if (dx*dx + dz*dz > UNLOAD_RADIUS * UNLOAD_RADIUS) {
      clearChunkMeshes(chunk);
      chunks.delete(ck);
    }
  }
}

function addBlockAt(x, y, z, type) {
  const info = getChunkAndLocal(x, y, z);

  if (!info) {
    // Chunk not loaded yet — load it and retry
    ensureChunk(Math.floor(x / CHUNK_SIZE), Math.floor(z / CHUNK_SIZE));
    return addBlockAt(x, y, z, type);
  }

  const { chunk, lx, lz } = info;
  const k = blockKey(lx, y, lz);

  if (chunk.blocks.has(k)) return;

  chunk.blocks.set(k, { type });
  buildChunkMeshes(chunk);
}


// -----------------------------------------------------
// MAIN UPDATE LOOP
// -----------------------------------------------------

let lastTime = performance.now();

function update(dt) {
  // Camera orientation
  camera.rotation.y = yaw;
  camera.rotation.x = pitch;

  // Load/unload chunks
  updateChunksAroundPlayer();

  // Movement + physics
  updateMovement(dt);


  // Camera follows player
  camera.position.set(
    player.pos.x,
    player.pos.y + player.height * 0.9,
    player.pos.z
  );

  // Debug info
  infoEl.textContent =
    `FPS: ${(1/dt).toFixed(0)} | ` +
    `Pos: ${player.pos.x.toFixed(1)}, ${player.pos.y.toFixed(1)}, ${player.pos.z.toFixed(1)}`;
}

function loop(now) {
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;

  update(dt);
  renderer.render(scene, camera);

  requestAnimationFrame(loop);
}

// -----------------------------------------------------
// INITIAL WORLD LOAD + START LOOP
// -----------------------------------------------------

updateChunksAroundPlayer();
requestAnimationFrame(loop);
</script>
</body>
</html>
